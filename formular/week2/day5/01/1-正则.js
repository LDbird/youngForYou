/*
* 正则：是一个用来处理字符串的规则。
*   1. 正则只能处理字符串；
*   2. 处理一般包含两方面的内容：
*     2.1 验证字符串是否符合某个规则【正则匹配】
*     2.2 把一个字符串中符合规则的部分捕获到【正则捕获】
*
* 学习正则其实就是学习如何编写规则，每个正则都是由“元字符”和“修饰符”两部分构成的。
*
* */

// 1. 创建正则有两种方式
let reg = /^\d$/g; // 字面量的方式创建的正则
let reg2 = new RegExp('^\\d$', 'g'); // 实例方式创建一个正则
// 使用字面量和实例的方式创建的正则都是RegExp的实例，在使用的时候没有任何的区别，只是在创建时略有不同。

// 2. 正则中两个斜杠包起来的都是“元字符”，斜杠后面出现都是“修饰符”

// let reg3 = /a/img; // 注意：修饰符可以联合使用

/*
* 【常用修饰符】
* g: global 全局匹配
* i: ignoreCase 忽略大小写匹配
* m: multiline 多行匹配
*
* */

/*
* 【常用的元字符】
*   【特殊元字符】
*     \d 0-9之间的一个数字
*     \D 除0-9以外的任意一个字符
*     \w 数字、字母、_(下划线) 中的任意一个字符
*     \s 匹配一个空白符（包含\t 【tab按键 制表符：4个空格】）
*     \b 匹配一个单词边界 'zhu' z的左侧和u的右侧都是边界，'zhu-feng' z的左侧，u的右侧，f的左侧、g的右侧都是边界
*     \n 匹配一个换行符
*     . 在元字符里，不是小数点，而是表示除换行符(\n)以外的任意一个字符
*     \ 转义符，把普通元字符转义成具有特殊意义的字符，例如\d表示0-9的一个数字；把有特殊意义的字符，转义成普通字符，例如 \. 不在表示除\n以外的任意字符，而是表示普通小数点
*     ^ (读作：caret符) 以某个元字符开头
*     $ 以某个元字符结尾
*     x|y x或者y中的一个
*     [xyz] x/y/z中的一个
*     [^xyz] 除x/y/z的任意字符
*     [a-z] a~z中的任意一个字母
*     [A-Z] A-Z 中的任意一个字母
*     [^a-z] 除了a-z以外的任意一个字符
*     () 正则分组
*     (?:) 当前分组只匹配不捕获
*     (?=) 正向预查
*     (?!) 负向预查
*
*   【量词元字符】 量词：描述数量
*      * 出现零次到多次
*      ? 出现零次到一次（出现或者不出现）
*      + 出现一次到到多次
*      {n} 出现n
*      {n,} 至少出现n次
*      {n,m} 出现n次到m次
*   【普通元字符】
*     只要在正则中出现（基于字面量方式声明），除了特殊和有量词含义的元字符以外的，其余都是普通元字符
*
* */
