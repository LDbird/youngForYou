// let str = 'zhufeng{2018}zhufeng{2019}yangfan{2020}';
// let reg = /\{(\d+)\}/g; // {}花括号有特殊含义，表示出现多少次
// console.log(reg.exec(str)); // ['{2018}', '2018'] 正则捕获的时候，如果正则中存在分组，捕获的时候不仅把大正则匹配到的字符串捕获到（数组的第一项），而且把小分组匹配的内容也单独抽取出来（数组中的第二项开始就是小分组捕获的内容）即“分组捕获”，而/\{(?:\d+)\}/g ?:是用来防止分组捕获到的。

// console.log(str.match(reg)); // => ['{2018}', '{2019}', '{2020}'] 所以match方法也有自己的局限性，在正则设置 G的情况下，基于match捕获的内容只有大正则匹配的，小分组的内容并没有单独抽取出来（不写g和执行exec一样）。

// >> 连接词：可以通过完善我们之前写的myExec向数组中push一个对象，对象里面既有大正则匹配到的内容，又有分组匹配到的内容


//++++++++++++++++++++++++++++++++

// => 正则匹配还具有贪婪性：每一次匹配的时候，总是捕获到和正则匹配的最常的内容，例如：'2' 也符合 \d+ '2018' 也符合 \d+ ，但是捕获的时候最长的内容 '2018'
let str = 'zhufeng{2018}zhufeng{2019}yangfan{2020}';
let reg = /\{(\d+)\}/g;
console.log(reg.exec(str));
// 解决正则的贪婪性：把问号放到量词元字符后面，代表的就不是出现零次或者一次了，而是取消正则的贪婪性

/*
* ? 在正则中的作用
*   1. 量词元字符，表示出现 0次到1次
*     /-?/ 让减号出现一次或者不出现
*   2. 量词元字符后面取消贪婪性
*     /\d+?/ 捕获的时候只捕获最短的匹配内容
*
*   3. 在分组中使用 ?: 表示只匹配不捕获
*     /(?:\d+)/ 只匹配一到多个数字且不捕获
*   4. ?= 正向预查
*   5. ?! 负向预查
*
* */

// >> 连接词：回环