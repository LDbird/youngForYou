/*
* 正则：是一个用来处理字符串的规则
*   1. 正则只能用来处理字符串
*   2. 处理一般包含两方面：
*     2.1 验证当前的字符串是否符合某个规则【正则匹配】 RegExp.prototype.test(字符串)
*     2.2 把符合当前规则的字符获取到 【正则捕获】 RegExp.prototype.exec(字符串)
*
*  学习正则就是学习如何编写正则，每一个正则都是由“元字符”和“修饰符”两部分组成的
*
*
* */

// => 创建正则的两种方式：
// let reg = /^\d+/img; // 字面量方式创建的正则
// let reg = new RegExp('^\\d+', 'img'); // 实例的方式创建

// => 2. 正则两个斜杠里面包起来大都是“元字符”，斜杠后面出现的都是“修饰符”

/*
* 常用的修饰符：
*   i: ignoreCase 忽略大小写匹配
*   m: multiline 多行匹配
*   g: global 全局匹配
*
*   注意：一个正则可以使用多个修饰符
*
*
* */


/*
* 常用的元字符：
*   【特殊元字符】
*     \d 匹配0-9的一个数字
*     \D 除0-9以外的任意一个字符
*     \w 数字、字母、下划线(_) 中的任意一个
*     \s 匹配一个空白符（包括\t [\t是匹配制表符 就是TAB键 一个制表符是4个空格]）
*     \b 匹配单词边界 'zhu' z的左侧、u的右侧是单词边界，'zhu-feng' z的左侧、u的右侧、f的左侧、g的右侧都是边界
*    \n 匹配一个换行符
*    . 不是小数点，是匹配除 \n 以外的任意字符
*    \ 转义符，将普通的字符转义成具有特殊含义的元字符，如\d就表示0-9之间的数字；还可以将特殊意义的字符转义成普通字符串，如\. 不再表除\n以外的任意字符而是表示一个普通的小数点
*
*    ^ （读作caret符）表示以某个元字符开头
*    $ 以某个元字符结尾
*    x|y 表示x或者y中的任意一个
*    [xyz] 表示x/y/z中的任意一个
*    [^xyz] 除x/y/z外的任意一个字符
*    [a-z] a-z中的任意一个字母
*    [0-9] 0-9的任意一个数字
*    [^a-z] 除了a-z以外的任意字符
*    () 正则分组
*    (?:) 当前分组只匹配不捕获
*    (?=) 正向预查
*    (?!) 负向预查
*
*   【量词元字符】
*     * 出现0次到多次
*     ? 出现0次到1次（就是要么出现要么不出现）
*     + 出现1次到多册
*     {n} 出现n次
*     {n,} 出现至少n次
*     {n,m} 出现n次到m次
*
*   【普通元字符】
*     只要在正则中出现，（基于字面量方式创建），除了特殊和有量词意义的以外，其余的都是普通元字符
*
* */